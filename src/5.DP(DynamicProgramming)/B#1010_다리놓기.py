# Upload BOJ Silver-5 DP 다리 놓기
    
# 0 -> 0
# 1 -> [(29*1)]
# 1 -> 29
# 2 -> [ [(28*1) * (1*1)] + [(26*1) * (1*1)] + ...  + [ (14*1) * (15*1) ] ]
# 2 -> 28 + 27 + 26 + ..... 1
# 3 -> 27 + 26 + 25 + 
# 3 -> 3*27 + 3(26*2) + 3(25*3*1) + 3(25*2*2)....

# 멍청한 놈...
# 생각보다 매우 간단한 문제...
# 좌측에 있는 포인트들과 우측에 있는 포인트들이 서로 겹치지 않게 연결이 되어야함
# 서로 겹치지 않게라는 말에 너무 신경 쓴 나머지 쓸데없는 고려를 하게 됨
# 예시로 13 29일 경우 13개의 포인터 중 첫 번째 포인트는 29개중 밑의 12개를 제외하고 다 연결될 수 있음
# 두번째 포인트는 첫 번째 포인트가 어디에 연결이 되었는지에 따라 연결될 수 있는 포인트 수가 달라짐..
# 위와 같은 생각을 하다보니 계산이 너무 복잡해진다는 것을 깨닳음 하지만 조합을 쓸 생각을 하지 못함
# 단순히 이걸 어떻게 DP로 풀 수 있을까? 라는 막연한 생각 밖에 하지 못함
# 그러다 우연히 번뜩이는 생각이 들었음
# 아니 우측에 있는 포인트들을 좌측에 있는 포인트들 만큼만 그냥 순서 없이 선택하면 되는거 아닌가?
# 일단 우측에 있는 포인트들을 좌측에 있는 포인트들 만큼 선택을 하게되면 그걸로 포인트들끼리 연결하면 되잖아? 라는 생각이 듦
# 여기서 선택해서 어쩔 건데? 결국 포인트들끼리 꼬이면 안되는데? 라는 생각을 할 수 있음
# 근데 깊게 생각해보면 사실 고려할 필요가 없음
# 우측에 있는 포인트들을 선택하면 자동으로 좌측에 있는 포인트들과 매칭이 된다.(순서대로 매칭이 될 수 밖에 없음)
# 즉, 우측에 있는 포인트들을 좌측에 있는 포인트들만큼만 조합으로 뽑으면 문제가 해결된다.
def combination(n,m):
    bunsu = 1
    for i in range(m,m-n,-1):
        bunsu *= i
    for i in range(1,n+1):
        bunsu //= i
        
    return bunsu

T = int(input())

for i in range(T):
    N, M = map(int, input().split())
    print(combination(N,M))
    
